{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Easier integrations with Faraday Agents \u00b6 Integrating systems is an elusive but mandatory job in any software product's life. Developers have to deal with languages they don't know, undocumented APIs or new paradigms. This leads to the fact that many product teams decide not to open the possibility to integrate to them. In Faraday \u2019s case, we are aware that integrations with other security tools are a critical part of our product. However, we\u2019ve realized that our Plugin system wasn't as easy as we expected to develop some integrations: it required some level of interactivity (either running a command from the console or importing a report), so it was hard to use on a periodic basis. It also forced integration developers to use our Python API, even when the tool to integrate with wasn't programmed in Python, making it harder for the developer. To solve this problem, we have the Faraday Agents ! You can use the getting started guide to use one of our official executors, or code and use one custom executor. Otherwise, you can use our docker image with all some tools already built and ready to go! You can also check our architecture or technical section, to understand how the agents works.","title":"Home"},{"location":"#easier-integrations-with-faraday-agents","text":"Integrating systems is an elusive but mandatory job in any software product's life. Developers have to deal with languages they don't know, undocumented APIs or new paradigms. This leads to the fact that many product teams decide not to open the possibility to integrate to them. In Faraday \u2019s case, we are aware that integrations with other security tools are a critical part of our product. However, we\u2019ve realized that our Plugin system wasn't as easy as we expected to develop some integrations: it required some level of interactivity (either running a command from the console or importing a report), so it was hard to use on a periodic basis. It also forced integration developers to use our Python API, even when the tool to integrate with wasn't programmed in Python, making it harder for the developer. To solve this problem, we have the Faraday Agents ! You can use the getting started guide to use one of our official executors, or code and use one custom executor. Otherwise, you can use our docker image with all some tools already built and ready to go! You can also check our architecture or technical section, to understand how the agents works.","title":"Easier integrations with Faraday Agents"},{"location":"418/","text":"418 - I'm a teapot \u00b6 This documentation is being build incrementally, so the page you were referenced, has not been done... yet","title":"418"},{"location":"418/#418-im-a-teapot","text":"This documentation is being build incrementally, so the page you were referenced, has not been done... yet","title":"418 - I'm a teapot"},{"location":"getting-started/","text":"Getting started \u00b6 Install \u00b6 pip $ pip install faraday_agent_dispatcher git $ git clone https://github.com/infobyte/faraday_agent_dispatcher.git $ cd faraday_agent_dispatcher $ pip install . Configure your agent \u00b6 The dispatcher can be configured with the wizard command: $ faraday-dispatcher config-wizard The wizard will ask for which configuration you would set, the agent configuration or the executors configuration . Agent configuration \u00b6 The proper configuration differ if you want to use SSL connection with your Faraday server. When using SSL you can use a self-signed certificate! Examples: https Example $ faraday-dispatcher config-wizard Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: A Section: server host [127.0.0.1]: ssl [True]: ssl_port [443]: Default SSL behavior? (Y, N): N ssl_cert []: Trying to save with empty value ssl_cert []: /home/path/to/the/cert.pub workspace [workspace]: sslWorkspace Section: agent agent_name [agent]: sslAgent Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: Q http Example $ faraday-dispatcher config-wizard Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: A Section: server host [127.0.0.1]: ssl [True]: False api_port [5985]: websocket_port [9000]: workspace [workspace]: sslFalseWorkspace Section: agent agent_name [agent]: sslFalseAgent Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: Q Warning We stronglly recommend to use https if not using within localhost Executors configuration \u00b6 When adding an executor you can set an executor with minimum configuration, which ones we maintain, call as official executor; or your own custom executors. In the next examples, you can see how to add a nessus executor, both as an official and custom executor: Official Example $ faraday-dispatcher config-wizard Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: E The actual configured executors are: [] Do you want to [A]dd, [M]odify or [D]elete an executor? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Name: official Is a custom executor? (Y, N) [N]: N The executors are: 1: wpscan.py 2: sublist3r.sh 3: nikto2.py 4: nessus.py 5: w3af.py +: Next page Q: Don't choose Choose one: 4 Max data sent to server [65536]: 65536 Environment variable NESSUS_USERNAME value: username Environment variable NESSUS_PASSWORD value: password Environment variable NESSUS_URL value: https://nessus_url.com The actual configured executors are: ['official'] Do you want to [A]dd, [M]odify or [D]elete an executor? Do you want to [Q]uit? (A, M, D, Q) [Q]: Q Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: Q Custom Example $ faraday-dispatcher config-wizard Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: E The actual configured executors are: [] Do you want to [A]dd, [M]odify or [D]elete an executor? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Name: custom Is a custom executor? (Y, N) [N]: Y Command to execute [exit 1]: python3 {REPO_FOLDER}/faraday_agent_dispatcher/static/executors/official/nessus.py Max data sent to server [65536]: 65536 The actual custom executor's environment variables are: [] Do you want to [A]dd, [M]odify or [D]elete an environment variable? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Environment variable name: NESSUS_USERNAME Environment variable value: username The actual custom executor's environment variables are: ['nessus_username'] Do you want to [A]dd, [M]odify or [D]elete an environment variable? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Environment variable name: NESSUS_PASSWORD Environment variable value: password The actual custom executor's environment variables are: ['nessus_username', 'nessus_password'] Do you want to [A]dd, [M]odify or [D]elete an environment variable? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Environment variable name: NESSUS_URL Environment variable value: https://nessus_url.com The actual custom executor's environment variables are: ['nessus_username', 'nessus_password', 'nessus_url'] Do you want to [A]dd, [M]odify or [D]elete an environment variable? Do you want to [Q]uit? (A, M, D, Q) [Q]: Q The actual custom executor's arguments are: [] Do you want to [A]dd, [M]odify or [D]elete an argument? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Argument name: NESSUS_SCAN_NAME Is mandatory? (Y, N): N The actual custom executor's arguments are: ['nessus_scan_name'] Do you want to [A]dd, [M]odify or [D]elete an argument? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Argument name: NESSUS_URL Is mandatory? (Y, N): N The actual custom executor's arguments are: ['nessus_scan_name', 'nessus_url'] Do you want to [A]dd, [M]odify or [D]elete an argument? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Argument name: NESSUS_SCAN_TARGET Is mandatory? (Y, N): Y The actual custom executor's arguments are: ['nessus_scan_name', 'nessus_url', 'nessus_scan_target'] Do you want to [A]dd, [M]odify or [D]elete an argument? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Argument name: NESSUS_SCAN_TEMPLATE Is mandatory? (Y, N): N The actual custom executor's arguments are: ['nessus_scan_name', 'nessus_url', 'nessus_scan_target', 'nessus_scan_template'] Do you want to [A]dd, [M]odify or [D]elete an argument? Do you want to [Q]uit? (A, M, D, Q) [Q]: Q The actual configured executors are: ['custom'] Do you want to [A]dd, [M]odify or [D]elete an executor? Do you want to [Q]uit? (A, M, D, Q) [Q]: Q Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: Q Warning Compared to the official executor example, this is more complex and ask for both arguments and configuration environment variables. We strongly recommend to read the custom executors technical section If you want to know how the executors work, you can check their technical section. Running the agent \u00b6 Start the agent \u00b6 The first time you run an agent, you need a token provided by the server That required token can be taken from the http(s):// {faraday_server_host} /#/admin/agents For example in: Your token is: 562107 The dispatcher can be executed with the run command, passing this token as an option: $ faraday-dispatcher run --token ={ TOKEN } Expected output The expected output when the dispatcher run command is as follows $ faraday-dispatcher run INFO - token_registration_url: { faraday_host } /_api/v3/ws/agent2/agent_registration INFO - Registered successfully INFO - Connection to Faraday server succeeded Warning The token is only needed the first time you run an agent, afterward you can run it without the option, as: $ faraday-dispatcher run Running an executor from faraday \u00b6 Go to https:// {faraday_server_host} /#/admin/agents Select your workspace in the dropdown Click Execute in the agent Select the executor and fill the arguments Click Run Expected output INFO - Parsing data: { \"execution_id\" : XX, \"agent_id\" : XX, \"action\" : \"RUN\" , \"executor\" : { EXECUTOR_NAME } , \"args\" : { EXECUTOR_ARGS }} INFO - Running { EXECUTOR_NAME } executor [ Executor data ] INFO - Executor { EXECUTOR_NAME } finished successfully Error output INFO - Parsing data: { \"execution_id\" : XX, \"agent_id\" : XX, \"action\" : \"RUN\" , \"executor\" : { EXECUTOR_NAME } , \"args\" : { EXECUTOR_ARGS }} INFO - Running { EXECUTOR_NAME } executor [ Executor data and errors ] WARNING - Executor { EXECUTOR_NAME } finished with exit code 1","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#install","text":"pip $ pip install faraday_agent_dispatcher git $ git clone https://github.com/infobyte/faraday_agent_dispatcher.git $ cd faraday_agent_dispatcher $ pip install .","title":"Install"},{"location":"getting-started/#configure-your-agent","text":"The dispatcher can be configured with the wizard command: $ faraday-dispatcher config-wizard The wizard will ask for which configuration you would set, the agent configuration or the executors configuration .","title":"Configure your agent"},{"location":"getting-started/#agent-configuration","text":"The proper configuration differ if you want to use SSL connection with your Faraday server. When using SSL you can use a self-signed certificate! Examples: https Example $ faraday-dispatcher config-wizard Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: A Section: server host [127.0.0.1]: ssl [True]: ssl_port [443]: Default SSL behavior? (Y, N): N ssl_cert []: Trying to save with empty value ssl_cert []: /home/path/to/the/cert.pub workspace [workspace]: sslWorkspace Section: agent agent_name [agent]: sslAgent Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: Q http Example $ faraday-dispatcher config-wizard Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: A Section: server host [127.0.0.1]: ssl [True]: False api_port [5985]: websocket_port [9000]: workspace [workspace]: sslFalseWorkspace Section: agent agent_name [agent]: sslFalseAgent Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: Q Warning We stronglly recommend to use https if not using within localhost","title":"Agent configuration"},{"location":"getting-started/#executors-configuration","text":"When adding an executor you can set an executor with minimum configuration, which ones we maintain, call as official executor; or your own custom executors. In the next examples, you can see how to add a nessus executor, both as an official and custom executor: Official Example $ faraday-dispatcher config-wizard Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: E The actual configured executors are: [] Do you want to [A]dd, [M]odify or [D]elete an executor? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Name: official Is a custom executor? (Y, N) [N]: N The executors are: 1: wpscan.py 2: sublist3r.sh 3: nikto2.py 4: nessus.py 5: w3af.py +: Next page Q: Don't choose Choose one: 4 Max data sent to server [65536]: 65536 Environment variable NESSUS_USERNAME value: username Environment variable NESSUS_PASSWORD value: password Environment variable NESSUS_URL value: https://nessus_url.com The actual configured executors are: ['official'] Do you want to [A]dd, [M]odify or [D]elete an executor? Do you want to [Q]uit? (A, M, D, Q) [Q]: Q Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: Q Custom Example $ faraday-dispatcher config-wizard Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: E The actual configured executors are: [] Do you want to [A]dd, [M]odify or [D]elete an executor? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Name: custom Is a custom executor? (Y, N) [N]: Y Command to execute [exit 1]: python3 {REPO_FOLDER}/faraday_agent_dispatcher/static/executors/official/nessus.py Max data sent to server [65536]: 65536 The actual custom executor's environment variables are: [] Do you want to [A]dd, [M]odify or [D]elete an environment variable? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Environment variable name: NESSUS_USERNAME Environment variable value: username The actual custom executor's environment variables are: ['nessus_username'] Do you want to [A]dd, [M]odify or [D]elete an environment variable? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Environment variable name: NESSUS_PASSWORD Environment variable value: password The actual custom executor's environment variables are: ['nessus_username', 'nessus_password'] Do you want to [A]dd, [M]odify or [D]elete an environment variable? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Environment variable name: NESSUS_URL Environment variable value: https://nessus_url.com The actual custom executor's environment variables are: ['nessus_username', 'nessus_password', 'nessus_url'] Do you want to [A]dd, [M]odify or [D]elete an environment variable? Do you want to [Q]uit? (A, M, D, Q) [Q]: Q The actual custom executor's arguments are: [] Do you want to [A]dd, [M]odify or [D]elete an argument? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Argument name: NESSUS_SCAN_NAME Is mandatory? (Y, N): N The actual custom executor's arguments are: ['nessus_scan_name'] Do you want to [A]dd, [M]odify or [D]elete an argument? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Argument name: NESSUS_URL Is mandatory? (Y, N): N The actual custom executor's arguments are: ['nessus_scan_name', 'nessus_url'] Do you want to [A]dd, [M]odify or [D]elete an argument? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Argument name: NESSUS_SCAN_TARGET Is mandatory? (Y, N): Y The actual custom executor's arguments are: ['nessus_scan_name', 'nessus_url', 'nessus_scan_target'] Do you want to [A]dd, [M]odify or [D]elete an argument? Do you want to [Q]uit? (A, M, D, Q) [Q]: A Argument name: NESSUS_SCAN_TEMPLATE Is mandatory? (Y, N): N The actual custom executor's arguments are: ['nessus_scan_name', 'nessus_url', 'nessus_scan_target', 'nessus_scan_template'] Do you want to [A]dd, [M]odify or [D]elete an argument? Do you want to [Q]uit? (A, M, D, Q) [Q]: Q The actual configured executors are: ['custom'] Do you want to [A]dd, [M]odify or [D]elete an executor? Do you want to [Q]uit? (A, M, D, Q) [Q]: Q Do you want to edit the [A]gent or the [E]xecutors? Do you want to [Q]uit? (A, E, Q) [Q]: Q Warning Compared to the official executor example, this is more complex and ask for both arguments and configuration environment variables. We strongly recommend to read the custom executors technical section If you want to know how the executors work, you can check their technical section.","title":"Executors configuration"},{"location":"getting-started/#running-the-agent","text":"","title":"Running the agent"},{"location":"getting-started/#start-the-agent","text":"The first time you run an agent, you need a token provided by the server That required token can be taken from the http(s):// {faraday_server_host} /#/admin/agents For example in: Your token is: 562107 The dispatcher can be executed with the run command, passing this token as an option: $ faraday-dispatcher run --token ={ TOKEN } Expected output The expected output when the dispatcher run command is as follows $ faraday-dispatcher run INFO - token_registration_url: { faraday_host } /_api/v3/ws/agent2/agent_registration INFO - Registered successfully INFO - Connection to Faraday server succeeded Warning The token is only needed the first time you run an agent, afterward you can run it without the option, as: $ faraday-dispatcher run","title":"Start the agent"},{"location":"getting-started/#running-an-executor-from-faraday","text":"Go to https:// {faraday_server_host} /#/admin/agents Select your workspace in the dropdown Click Execute in the agent Select the executor and fill the arguments Click Run Expected output INFO - Parsing data: { \"execution_id\" : XX, \"agent_id\" : XX, \"action\" : \"RUN\" , \"executor\" : { EXECUTOR_NAME } , \"args\" : { EXECUTOR_ARGS }} INFO - Running { EXECUTOR_NAME } executor [ Executor data ] INFO - Executor { EXECUTOR_NAME } finished successfully Error output INFO - Parsing data: { \"execution_id\" : XX, \"agent_id\" : XX, \"action\" : \"RUN\" , \"executor\" : { EXECUTOR_NAME } , \"args\" : { EXECUTOR_ARGS }} INFO - Running { EXECUTOR_NAME } executor [ Executor data and errors ] WARNING - Executor { EXECUTOR_NAME } finished with exit code 1","title":"Running an executor from faraday"},{"location":"examples/new-custom-executor/","text":"","title":"New custom executor"},{"location":"misc/docker/","text":"Agent Docker image \u00b6 Usage \u00b6 The image is already published in our dockehub page , so you just have to pull our image with the following command $ docker pull faradaysec/faraday_agent_dispatcher After that you only need a .ini file to pass to the image. We already have some templates to use. For these you have to edit it in the first lines: [server] ; TODO be replaced with network configuration host = localhost ssl = False api_port = 5985 websocket_port = 9000 ssl_cert = ; TODO be filled with available workspaces workspaces = After setting the values in the .ini file, you can run the agent as: $ docker run -v { ABSOLUTE_PATH_TO_INI } :/root/.faraday/config/dispatcher.ini -it faradaysec/faraday_agent_dispatcher --token ={ TOKEN } Warning As we explain in the getting started guide , you only need the token the first time you run an agent Templates \u00b6 We currently have 2 templates: Base Agent This template use is as simple as shown above $ docker run -v { ABSOLUTE_PATH_TO_INI } :/root/.faraday/config/dispatcher.ini -it faradaysec/faraday_agent_dispatcher --token ={ TOKEN } With reports This template adds the possibility of use a path to read reports from the host machine. $ docker run -v { ABSOLUTE_PATH_TO_INI } :/root/.faraday/config/dispatcher.ini -v { ABSOLUTE_PATH_TO_REPORT_FOLDER } :/root/reports/ -it faradaysec/faraday_agent_dispatcher --token ={ TOKEN } Then you can process any report by just specifying the route to the report file as an executor parameter","title":"Docker"},{"location":"misc/docker/#agent-docker-image","text":"","title":"Agent Docker image"},{"location":"misc/docker/#usage","text":"The image is already published in our dockehub page , so you just have to pull our image with the following command $ docker pull faradaysec/faraday_agent_dispatcher After that you only need a .ini file to pass to the image. We already have some templates to use. For these you have to edit it in the first lines: [server] ; TODO be replaced with network configuration host = localhost ssl = False api_port = 5985 websocket_port = 9000 ssl_cert = ; TODO be filled with available workspaces workspaces = After setting the values in the .ini file, you can run the agent as: $ docker run -v { ABSOLUTE_PATH_TO_INI } :/root/.faraday/config/dispatcher.ini -it faradaysec/faraday_agent_dispatcher --token ={ TOKEN } Warning As we explain in the getting started guide , you only need the token the first time you run an agent","title":"Usage"},{"location":"misc/docker/#templates","text":"We currently have 2 templates: Base Agent This template use is as simple as shown above $ docker run -v { ABSOLUTE_PATH_TO_INI } :/root/.faraday/config/dispatcher.ini -it faradaysec/faraday_agent_dispatcher --token ={ TOKEN } With reports This template adds the possibility of use a path to read reports from the host machine. $ docker run -v { ABSOLUTE_PATH_TO_INI } :/root/.faraday/config/dispatcher.ini -v { ABSOLUTE_PATH_TO_REPORT_FOLDER } :/root/reports/ -it faradaysec/faraday_agent_dispatcher --token ={ TOKEN } Then you can process any report by just specifying the route to the report file as an executor parameter","title":"Templates"},{"location":"technical/agents/","text":"Agents \u00b6 Using Faraday to upload reports from tools is great. But when automatizing a scan, it is not expected to write scripts mixing its Python API configuration with the scan code. Moreover, if the scan code is in other language and/or another host, there will be code mangling the http connection. On runtime, the Faraday Agent will be in charge of the connection, and be focus on the code automatizing the scan. Executors \u00b6 The important code which the Agent can run resides in the Executors, it can be in any language, and interact with any other resources. The only expected behaviour is as it were part of a shell pipeline, meaning that its output is expected to by: stdout: Only relevant data sent to Faraday, it must be in json format, expected to be received by the Faraday API stderr: All kind of info not relevant to Faraday, such as information and errors. End of file Both stdout and stderr are assumed closed by receiving double \\n . Some executors are parametrized by: Environment variables: These contains fixed or private configuration, such as API Tokens, directory or file path, etc. Arguments: These parameters comes from Faraday, and can differ between executions, such as IP range, a feature flag, etc. All parameters goes by environment variables, prefixed as EXECUTOR_CONFIG_{PARAM_NAME} to not conflict with actual environment variables. It is configurable if they are mandatory or not. Info All that configuration allows executor debugging being a lot more easier, not needing the Agent to be run, only with a shell command $ ./my_executor # This assume, as within the agent, that the enviroment is ready Official executors \u00b6 The Faraday agent is shipped with some pre-configured executors. While configuring the agent with the configuration wizard , it will already know with are the environment variables and arguments. It will ask for the variables values and will be ready to go. These executors are in faraday_agent_dispatcher/static/executors/official , and all their configuration is in its own manifest JSON file. Custom executors \u00b6 When requiring a custom executor, its possible to configuring them with the configuration wizard , and it will ask for which are the environment variables and their value as for the parameters, and whether they are mandatory or not. Dispatcher \u00b6 The agent dispatcher is a middleware, between the executors, and the Faraday server. It will handle the multiple processes and communication with them, and with the server. Communication with Faraday \u00b6 When communicating with Faraday there are some things to be aware of: The agent initiates the communication, no matter if it is registering itself as a new agent or just connecting in an restart process. The server has a collection of Agents to run executors, and has the ability to say when to run them. A never ending executor, always receive the first start command from the server. For now, the agent only post data to the server, when any executor says it has new data. That being said, it is clearly separated between two different type of connection between Agent and server: REST API: General data, such as registering a new agent and publishing new data. Its always the agent interacting with the server. Websockets: Commands data, its a separated protocol for agents management. REST API \u00b6 Faraday has a vast REST API, and there are a few endpoints used by the agent, which are used for: /_api/v3/info : Connectivity check. /_api/v3/agent_registration : Registration of a new agent. /_api/v3/agent_websocket_token : Get a websocket token. /_api/v3/ws/{workspace_name}/bulk_create : Publish data to a specific workspace REST API Documentarion For more info about the API, use its own documentation Websockets \u00b6 For commands, a bidirectional communication is expected between the Agent and the server. The server can only send a RUN command, specifying which executor to run, its parameters and to which workspace post the data. It also has some metadata relevant to the faraday server to identify the execution. The agent is able to notify the server with three actions: JOIN_AGENT : Notify the server it is ready to run, which executors are available and their params. LEAVE_AGENT : Notify of disconnection. RUN_STATUS : After a RUN command, notify if something was wrong and won't run, or if the executor run successfully or not. Communication with executors \u00b6 As mentioned before , executors take parameters and environment variables as input methods, and standard files as stderr and stdout as output methods. Why is the agent asynchronous? \u00b6 There are some reasons for that: It is expected the dispatcher runs multiples executors at the same time, and isn't waiting to be finished while midway data is ready to be sent. Moreover, the dispatcher is just a IO-bound middleware, waiting for news from the server or the executors. Finally, the executors can be written in any language, that means they can be in the same process. All these features can be accomplished by using Python asyncio in the development of it. So, the dispatcher is a single-process with single-threading. Its living coroutines basically are: A waiting coroutine for web-sockets commands. A launch executor coroutine. The listen a stderr and stdout from executor coroutines. Warning As its mentioned there are only 3 types of living coroutines, but are multiple running. The main coroutine is always running or waiting, and 3 more coroutines are running for each executor.","title":"Agents"},{"location":"technical/agents/#agents","text":"Using Faraday to upload reports from tools is great. But when automatizing a scan, it is not expected to write scripts mixing its Python API configuration with the scan code. Moreover, if the scan code is in other language and/or another host, there will be code mangling the http connection. On runtime, the Faraday Agent will be in charge of the connection, and be focus on the code automatizing the scan.","title":"Agents"},{"location":"technical/agents/#executors","text":"The important code which the Agent can run resides in the Executors, it can be in any language, and interact with any other resources. The only expected behaviour is as it were part of a shell pipeline, meaning that its output is expected to by: stdout: Only relevant data sent to Faraday, it must be in json format, expected to be received by the Faraday API stderr: All kind of info not relevant to Faraday, such as information and errors. End of file Both stdout and stderr are assumed closed by receiving double \\n . Some executors are parametrized by: Environment variables: These contains fixed or private configuration, such as API Tokens, directory or file path, etc. Arguments: These parameters comes from Faraday, and can differ between executions, such as IP range, a feature flag, etc. All parameters goes by environment variables, prefixed as EXECUTOR_CONFIG_{PARAM_NAME} to not conflict with actual environment variables. It is configurable if they are mandatory or not. Info All that configuration allows executor debugging being a lot more easier, not needing the Agent to be run, only with a shell command $ ./my_executor # This assume, as within the agent, that the enviroment is ready","title":"Executors"},{"location":"technical/agents/#official-executors","text":"The Faraday agent is shipped with some pre-configured executors. While configuring the agent with the configuration wizard , it will already know with are the environment variables and arguments. It will ask for the variables values and will be ready to go. These executors are in faraday_agent_dispatcher/static/executors/official , and all their configuration is in its own manifest JSON file.","title":"Official executors"},{"location":"technical/agents/#custom-executors","text":"When requiring a custom executor, its possible to configuring them with the configuration wizard , and it will ask for which are the environment variables and their value as for the parameters, and whether they are mandatory or not.","title":"Custom executors"},{"location":"technical/agents/#dispatcher","text":"The agent dispatcher is a middleware, between the executors, and the Faraday server. It will handle the multiple processes and communication with them, and with the server.","title":"Dispatcher"},{"location":"technical/agents/#communication-with-faraday","text":"When communicating with Faraday there are some things to be aware of: The agent initiates the communication, no matter if it is registering itself as a new agent or just connecting in an restart process. The server has a collection of Agents to run executors, and has the ability to say when to run them. A never ending executor, always receive the first start command from the server. For now, the agent only post data to the server, when any executor says it has new data. That being said, it is clearly separated between two different type of connection between Agent and server: REST API: General data, such as registering a new agent and publishing new data. Its always the agent interacting with the server. Websockets: Commands data, its a separated protocol for agents management.","title":"Communication with Faraday"},{"location":"technical/agents/#rest-api","text":"Faraday has a vast REST API, and there are a few endpoints used by the agent, which are used for: /_api/v3/info : Connectivity check. /_api/v3/agent_registration : Registration of a new agent. /_api/v3/agent_websocket_token : Get a websocket token. /_api/v3/ws/{workspace_name}/bulk_create : Publish data to a specific workspace REST API Documentarion For more info about the API, use its own documentation","title":"REST API"},{"location":"technical/agents/#websockets","text":"For commands, a bidirectional communication is expected between the Agent and the server. The server can only send a RUN command, specifying which executor to run, its parameters and to which workspace post the data. It also has some metadata relevant to the faraday server to identify the execution. The agent is able to notify the server with three actions: JOIN_AGENT : Notify the server it is ready to run, which executors are available and their params. LEAVE_AGENT : Notify of disconnection. RUN_STATUS : After a RUN command, notify if something was wrong and won't run, or if the executor run successfully or not.","title":"Websockets"},{"location":"technical/agents/#communication-with-executors","text":"As mentioned before , executors take parameters and environment variables as input methods, and standard files as stderr and stdout as output methods.","title":"Communication with executors"},{"location":"technical/agents/#why-is-the-agent-asynchronous","text":"There are some reasons for that: It is expected the dispatcher runs multiples executors at the same time, and isn't waiting to be finished while midway data is ready to be sent. Moreover, the dispatcher is just a IO-bound middleware, waiting for news from the server or the executors. Finally, the executors can be written in any language, that means they can be in the same process. All these features can be accomplished by using Python asyncio in the development of it. So, the dispatcher is a single-process with single-threading. Its living coroutines basically are: A waiting coroutine for web-sockets commands. A launch executor coroutine. The listen a stderr and stdout from executor coroutines. Warning As its mentioned there are only 3 types of living coroutines, but are multiple running. The main coroutine is always running or waiting, and 3 more coroutines are running for each executor.","title":"Why is the agent asynchronous?"},{"location":"technical/arch/","text":"Architecture \u00b6 Faraday is a web application, the server is made with Python using Flask. Its possible to automatize tool usage with Faraday agents . Faraday server \u00b6 Faraday is accessed by a Web Browser or the Faraday Client . Both clients, communicate with Faraday Server via its REST API . The server has other main components as the Report Processor, or the Websocket Server. The latter provides information to the Client. Faraday agent \u00b6 The agent is an application composed by scripts discovering information, called executors . They can access any external services or use the Faraday's Report Processor. The data found by them is sent to the Faraday server by a middleware called Dispatcher , which will be the only module communicating with the server. Moreover, the Dispatcher is in charge of the scheduling of executors, backed by its implementation with asyncio . The Dispatcher uses the Faraday API to first communication and publishing the data, specially the bulk_create endpoint . In addition, the only communication via the websocket server are the commands from faraday, such as which executor will run and its arguments values, execution status updates, etc. The executors communicates by the standard output the data to publish, and by the standard error any information about the run.","title":"Architecture"},{"location":"technical/arch/#architecture","text":"Faraday is a web application, the server is made with Python using Flask. Its possible to automatize tool usage with Faraday agents .","title":"Architecture"},{"location":"technical/arch/#faraday-server","text":"Faraday is accessed by a Web Browser or the Faraday Client . Both clients, communicate with Faraday Server via its REST API . The server has other main components as the Report Processor, or the Websocket Server. The latter provides information to the Client.","title":"Faraday server"},{"location":"technical/arch/#faraday-agent","text":"The agent is an application composed by scripts discovering information, called executors . They can access any external services or use the Faraday's Report Processor. The data found by them is sent to the Faraday server by a middleware called Dispatcher , which will be the only module communicating with the server. Moreover, the Dispatcher is in charge of the scheduling of executors, backed by its implementation with asyncio . The Dispatcher uses the Faraday API to first communication and publishing the data, specially the bulk_create endpoint . In addition, the only communication via the websocket server are the commands from faraday, such as which executor will run and its arguments values, execution status updates, etc. The executors communicates by the standard output the data to publish, and by the standard error any information about the run.","title":"Faraday agent"}]}